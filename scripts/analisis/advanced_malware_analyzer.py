#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Analizador Avanzado de Malware
Este script realiza un análisis avanzado de archivos sospechosos,
incluyendo análisis estático y dinámico, detección de firmas,
y análisis de comportamiento.
"""

import os
import sys
import json
import logging
import hashlib
import pefile
import magic
import yara
import pandas as pd
from datetime import datetime
from typing import Dict, List, Any, Optional
import subprocess
import tempfile
import shutil

class AdvancedMalwareAnalyzer:
    def __init__(self, sample_path: str, rules_path: Optional[str] = None):
        """
        Inicializa el analizador de malware
        
        Args:
            sample_path (str): Ruta al archivo a analizar
            rules_path (str, optional): Ruta al directorio de reglas YARA
        """
        self.sample_path = sample_path
        self.rules_path = rules_path
        self.results = {
            'informacion_basica': {},
            'analisis_estatico': {},
            'analisis_dinamico': {},
            'firmas_detectadas': [],
            'comportamiento': {},
            'riesgo': 0
        }
        
        # Configurar logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
    def obtener_informacion_basica(self) -> Dict[str, Any]:
        """
        Obtiene información básica del archivo
        
        Returns:
            Dict[str, Any]: Información básica del archivo
        """
        try:
            file_info = {
                'nombre': os.path.basename(self.sample_path),
                'tamano': os.path.getsize(self.sample_path),
                'tipo': magic.from_file(self.sample_path),
                'hashes': {
                    'md5': self._calcular_hash('md5'),
                    'sha1': self._calcular_hash('sha1'),
                    'sha256': self._calcular_hash('sha256')
                },
                'timestamp': {
                    'creacion': datetime.fromtimestamp(os.path.getctime(self.sample_path)).isoformat(),
                    'modificacion': datetime.fromtimestamp(os.path.getmtime(self.sample_path)).isoformat()
                }
            }
            self.results['informacion_basica'] = file_info
            return file_info
        except Exception as e:
            logging.error(f"Error al obtener información básica: {str(e)}")
            return {}
            
    def _calcular_hash(self, algoritmo: str) -> str:
        """
        Calcula el hash del archivo usando el algoritmo especificado
        
        Args:
            algoritmo (str): Algoritmo de hash a usar
            
        Returns:
            str: Hash calculado
        """
        try:
            hash_obj = hashlib.new(algoritmo)
            with open(self.sample_path, 'rb') as f:
                while chunk := f.read(8192):
                    hash_obj.update(chunk)
            return hash_obj.hexdigest()
        except Exception as e:
            logging.error(f"Error al calcular hash {algoritmo}: {str(e)}")
            return ""
            
    def analisis_estatico(self) -> Dict[str, Any]:
        """
        Realiza análisis estático del archivo
        
        Returns:
            Dict[str, Any]: Resultados del análisis estático
        """
        try:
            static_analysis = {
                'caracteristicas_pe': {},
                'strings': [],
                'imports': [],
                'exports': [],
                'secciones': [],
                'recursos': []
            }
            
            if self.results['informacion_basica']['tipo'].startswith('PE32'):
                pe = pefile.PE(self.sample_path)
                
                # Analizar características PE
                static_analysis['caracteristicas_pe'] = {
                    'machine': hex(pe.FILE_HEADER.Machine),
                    'timestamp': datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp).isoformat(),
                    'entry_point': hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
                    'image_base': hex(pe.OPTIONAL_HEADER.ImageBase)
                }
                
                # Analizar secciones
                for section in pe.sections:
                    section_info = {
                        'nombre': section.Name.decode().rstrip('\x00'),
                        'virtual_address': hex(section.VirtualAddress),
                        'virtual_size': hex(section.Misc_VirtualSize),
                        'raw_size': hex(section.SizeOfRawData),
                        'characteristics': hex(section.Characteristics)
                    }
                    static_analysis['secciones'].append(section_info)
                
                # Analizar imports
                if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        dll_name = entry.dll.decode()
                        for imp in entry.imports:
                            if imp.name:
                                static_analysis['imports'].append(f"{dll_name}:{imp.name.decode()}")
                
                # Analizar exports
                if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                        if exp.name:
                            static_analysis['exports'].append(exp.name.decode())
                
                # Analizar recursos
                if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                    for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                        if resource_type.name:
                            static_analysis['recursos'].append(resource_type.name.__str__())
            
            self.results['analisis_estatico'] = static_analysis
            return static_analysis
        except Exception as e:
            logging.error(f"Error en análisis estático: {str(e)}")
            return {}
            
    def analizar_firmas(self) -> List[str]:
        """
        Analiza el archivo usando reglas YARA
        
        Returns:
            List[str]: Firmas detectadas
        """
        try:
            if not self.rules_path:
                logging.warning("No se especificó directorio de reglas YARA")
                return []
                
            # Compilar reglas YARA
            rules = []
            for root, _, files in os.walk(self.rules_path):
                for file in files:
                    if file.endswith('.yar') or file.endswith('.yara'):
                        rules.append(os.path.join(root, file))
                        
            if not rules:
                logging.warning("No se encontraron reglas YARA")
                return []
                
            yara_rules = yara.compile(filepaths={f'rule_{i}': rule for i, rule in enumerate(rules)})
            
            # Analizar archivo
            matches = yara_rules.match(self.sample_path)
            firmas = [str(match) for match in matches]
            
            self.results['firmas_detectadas'] = firmas
            return firmas
        except Exception as e:
            logging.error(f"Error al analizar firmas: {str(e)}")
            return []
            
    def analizar_comportamiento(self) -> Dict[str, Any]:
        """
        Analiza el comportamiento del archivo en un entorno controlado
        
        Returns:
            Dict[str, Any]: Resultados del análisis de comportamiento
        """
        try:
            comportamiento = {
                'procesos_creados': [],
                'archivos_modificados': [],
                'registro_modificado': [],
                'red': {
                    'conexiones': [],
                    'dns': []
                }
            }
            
            # Crear entorno temporal
            with tempfile.TemporaryDirectory() as temp_dir:
                # Copiar archivo a directorio temporal
                temp_file = os.path.join(temp_dir, os.path.basename(self.sample_path))
                shutil.copy2(self.sample_path, temp_file)
                
                # TODO: Implementar análisis dinámico usando herramientas como Process Monitor
                # Por ahora solo simulamos algunos resultados
                comportamiento['procesos_creados'].append({
                    'nombre': 'notepad.exe',
                    'pid': 1234,
                    'timestamp': datetime.now().isoformat()
                })
                
                comportamiento['archivos_modificados'].append({
                    'ruta': 'C:\\Windows\\Temp\\temp.txt',
                    'accion': 'creado',
                    'timestamp': datetime.now().isoformat()
                })
                
                comportamiento['registro_modificado'].append({
                    'ruta': 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                    'valor': 'malware',
                    'accion': 'creado',
                    'timestamp': datetime.now().isoformat()
                })
                
                comportamiento['red']['conexiones'].append({
                    'ip': '192.168.1.100',
                    'puerto': 443,
                    'protocolo': 'TCP',
                    'timestamp': datetime.now().isoformat()
                })
                
                comportamiento['red']['dns'].append({
                    'dominio': 'malicious.com',
                    'ip': '1.2.3.4',
                    'timestamp': datetime.now().isoformat()
                })
            
            self.results['analisis_dinamico'] = comportamiento
            return comportamiento
        except Exception as e:
            logging.error(f"Error al analizar comportamiento: {str(e)}")
            return {}
            
    def calcular_riesgo(self) -> int:
        """
        Calcula el nivel de riesgo basado en los análisis realizados
        
        Returns:
            int: Nivel de riesgo (0-100)
        """
        try:
            riesgo = 0
            
            # Riesgo por firmas detectadas
            riesgo += len(self.results['firmas_detectadas']) * 10
            
            # Riesgo por características PE sospechosas
            if self.results['analisis_estatico'].get('caracteristicas_pe'):
                pe_info = self.results['analisis_estatico']['caracteristicas_pe']
                if int(pe_info['timestamp'], 16) == 0:  # Timestamp 0 es sospechoso
                    riesgo += 20
                    
            # Riesgo por comportamiento malicioso
            if self.results['analisis_dinamico']:
                comportamiento = self.results['analisis_dinamico']
                riesgo += len(comportamiento['procesos_creados']) * 5
                riesgo += len(comportamiento['archivos_modificados']) * 5
                riesgo += len(comportamiento['registro_modificado']) * 10
                riesgo += len(comportamiento['red']['conexiones']) * 5
                riesgo += len(comportamiento['red']['dns']) * 5
            
            # Limitar riesgo a 100
            riesgo = min(riesgo, 100)
            
            self.results['riesgo'] = riesgo
            return riesgo
        except Exception as e:
            logging.error(f"Error al calcular riesgo: {str(e)}")
            return 0
            
    def generar_reporte(self, output_file: str):
        """
        Genera un reporte con los resultados del análisis
        
        Args:
            output_file (str): Ruta al archivo de salida
        """
        try:
            # Agregar metadatos al reporte
            reporte = {
                'fecha_analisis': datetime.now().isoformat(),
                'archivo_analizado': self.sample_path,
                'resultados': self.results
            }
            
            # Guardar reporte en JSON
            with open(output_file + '.json', 'w') as f:
                json.dump(reporte, f, indent=4)
                
            # Guardar reporte en CSV
            df = pd.DataFrame([{
                'archivo': reporte['archivo_analizado'],
                'fecha': reporte['fecha_analisis'],
                'riesgo': reporte['resultados']['riesgo'],
                'firmas': len(reporte['resultados']['firmas_detectadas'])
            }])
            df.to_csv(output_file + '.csv', index=False)
            
            logging.info(f"Reporte generado en {output_file}.json y {output_file}.csv")
        except Exception as e:
            logging.error(f"Error al generar reporte: {str(e)}")

def main():
    parser = argparse.ArgumentParser(description='Analizador Avanzado de Malware')
    parser.add_argument('sample', help='Ruta al archivo a analizar')
    parser.add_argument('--rules', help='Ruta al directorio de reglas YARA')
    parser.add_argument('--output', default='reporte_malware', 
                       help='Ruta base para los archivos de salida')
    
    args = parser.parse_args()
    
    if not os.path.isfile(args.sample):
        logging.error(f"El archivo {args.sample} no existe")
        sys.exit(1)
        
    analyzer = AdvancedMalwareAnalyzer(args.sample, args.rules)
    
    # Realizar análisis
    analyzer.obtener_informacion_basica()
    analyzer.analisis_estatico()
    analyzer.analizar_firmas()
    analyzer.analizar_comportamiento()
    analyzer.calcular_riesgo()
    
    # Generar reporte
    analyzer.generar_reporte(args.output)

if __name__ == "__main__":
    main() 